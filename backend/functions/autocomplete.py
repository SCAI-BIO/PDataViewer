"""
The autocomplete module provides functionality to suggest autocompletions based on a given query.
It leverages regular expression matching and fuzzy string matching to generate suggestions from
a list of features.

The module includes the following function:
- autocomplete(text: str, folder="./cdm", threshold=80, limit=10) -> list[str]:
    Provides autocomplete suggestions based on the given query by performing regex and fuzzy matching.

Usage example:
---------------
To get autocomplete suggestions for the query 'Feat' using the data in the './cdm' folder:

    from functions.autocomplete import autocomplete

    suggestions = autocomplete(text='Feat', folder='./cdm')
    print(suggestions)

Dependencies:
--------------
- re: For removing regular expression operations.
- thefuzz: For fuzzy string matching.
- functions.preprocessing: For the `merge_modalities` function to obtain feature data.

Exceptions:
-----------
The `autocomplete` function does not explicitly raise any exceptions but relies on 
the underlying functions and libraries which may raise their respective exceptions.
"""

import re
from thefuzz import process, fuzz
from functions.preprocessing import merge_modalities


def autocomplete(text: str, folder="./cdm", threshold=80, limit=10):
    """Gives autocomplete suggestions based on the given query.

    Args:
        text (str): Query given by the user
        folder (str, optional): Path to folder containing the modalities. Defaults to "./cdm".

    Returns:
        suggestions (list[str]): A list of suggestions
    """
    # Remove special characters that have syntactic meaning in regex
    text = re.sub(r'[.*+?^${}()|[\]\\]', '', text)
    # Get features and convert them into a list
    features = merge_modalities(usecols=["Feature"], folder=folder)
    features = features["Feature"].to_list()
    # Compile the regex pattern
    pattern = re.compile(r'^' + text, re.IGNORECASE)
    # Perform regex pattern matching
    suggestions = [suggestion for suggestion in features if pattern.match(suggestion)]
    # Limit the list of suggestions to a length of 10
    suggestions = suggestions[:10]
    # Sort the list elements in ascending order based in the length
    suggestions.sort(key=lambda s: len(s))

    # If there is no matching prefix
    if not suggestions:
        suggestions = process.extract(text, features, scorer=fuzz.partial_token_set_ratio, limit=limit)
        suggestions = [suggestion[0] for suggestion in suggestions if suggestion[1] >= threshold]

    # If there is less than 10 suggestions
    elif len(suggestions) < 10:
        # Calculate the number of suggestions that will be generated by fuzzy
        limit = limit - len(suggestions)
        # Remove already suggested features from the features list
        suggestions_set = set(suggestions)
        features = [feature for feature in features if feature not in suggestions_set]
        # Generate fuzzy suggestions and populate suggestions list with it
        fuzzy_suggestions = process.extract(text, features, scorer=fuzz.partial_token_set_ratio, limit=limit)
        # Filter fuzzy suggestions based on the threshold
        fuzzy_suggestions = [suggestion[0] for suggestion in fuzzy_suggestions if suggestion[1] >= threshold]
        # Append fuzzy suggestions to the list of suggestions
        suggestions.extend(fuzzy_suggestions)
    
    return suggestions